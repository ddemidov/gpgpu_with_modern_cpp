\documentclass[1p]{elsarticle}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage[colorlinks,unicode,linkcolor=black]{hyperref}
\usepackage{listings}
\lstset{
    language=C++,
    basicstyle=\small,
    columns=flexible,
    showstringspaces=false,
    frame=single
    }
\newcommand{\code}[1]{\lstinline|#1|}
\newcommand{\figref}[1]{Fig.~\ref{#1}}

%
% mathematical commands
%
\newcommand {\re} {\text{Re}}
\newcommand {\im} {\text{Im}}
\newcommand {\de} {\mbox{d}}
\newcommand {\ii} {\text{i}}
\newcommand {\ee} {\text{e}}
\newcommand {\mathbi}[1] {\textbf{\em #1}}
\newcommand {\sign} {\text{sign}}
\newcommand {\bra}[1] {\langle #1 \mid}
\newcommand {\ket}[1] {\mid #1 \rangle}
\newcommand {\braket}[2] {\langle #1 \mid #2 \rangle}
\newcommand {\mean}[1] {\langle #1 \rangle}
\newcommand {\sech} {\text{sech}}
\newcommand {\conj} {\ast}



\journal{Journal of Parallel and Distributed Computing}

\begin{document}

\begin{frontmatter}

\title{Programming OpenCL and CUDA:\\a Case Study Using Modern C++ Libraries}

\author{Karsten Ahnert}
\ead{karsten.ahnert@gmx.de}
\address{
Institut f\"ur Physik und Astronomie, Universit\"at Potsdam,\\
Karl-Liebknecht-Strasse 24/25, 14476 Potsdam-Golm, Germany
}

\author{Denis Demidov}
\ead{ddemidov@ksu.ru}
\address{
Kazan Branch of Joint Supercomputer Center,
Russian Academy of Sciences,\\
Lobachevsky st. 2/31, 420008 Kazan, Russia
}

\begin{abstract}
    We present comparison of several modern C++ libraries intended for
    OpenCL and CUDA programming. The comparison is based on odeint~---
    a framework for solution of ordinary differential
    equations. Odeint is designed in a very flexible way such that the
    algorithms are completely independent from the underlying
    containers and even from the basic algebraic computations. This
    allows one to effectively use such libraries as VexCL, ViennaCL or
    Thrust to solve ODEs with either OpenCL or CUDA technologies. We
    found that OpenCL and CUDA work equally well for problems of large
    sizes, although OpenCL is not well suited for smaller problems due
    to its higher initialization overhead.
\end{abstract}

\begin{keyword}
    GPGPU \sep OpenCL \sep CUDA \sep Modern C++ libraries
\end{keyword}

\end{frontmatter}

\section{Introduction}

Recently, GPGPU based computing has acquired considerable momentum in
scientific community. This is confirmed both by increasing numbers of
GPGPU-related publications and GPU based supercomputers in Top
500\footnote{\href{http://top500.org/}{http://top500.org/}}
list. Furthermore, GPUs based hardware is usually much cheaper then
comparable CPU based computers. Major programming frameworks are
NVIDIA CUDA and OpenCL.  The former is proprietary parallel computing
architecture developed by Nvidia for general purpose computing on
Nvidia graphics cards, and the latter is open, royalty-free standard
for cross-platform, parallel programming of modern processors backed
by Khronos group. The frameworks have their distinctive pros and
cons. CUDA has more a mature programming environment with larger set of
scientific libraries; but it is only supported on NVIDIA
hardware. OpenCL is an open standard supported on wide range of
hardware but it requires much larger amount of boilerplate code from the
developer.

Both technologies are able to provide scientists with vast computational
resources of modern GPU cards. But the power comes with a price: GPGPU
programming has a steep learining curve. Programmer needs to familiarize
himself with (slightly) new programming language and, more importantly, with
new programming paradigm. However, the entry price may be lowered with help of
specialized libraries. CUDA provides several such libraries (BLAS
implementation, Fast Fourier Transform, Thrust and others). And there are many
third party librares for both CUDA and OpenCL.

This paper presents a comparison of several modern C++ libraries aimed at ease of
GPGPU development. We look at both ease of use and performance of the libraries
under consideration in the context of solving ordinary differential equations (ODEs).
The comparison is based on odeint~--- modern C++ library for solving the initial value problem of ODEs.
Odeint is designed in a very flexible way such that the algorithms are
completely independent from the underlying containers and even from the basic
algebraic computations. This allows to effectively use libraries implementing
basic linear algebra operations with either OpenCL or CUDA technologies for
solution of ODEs.

\section{Libraries used in comparison}

\subsection{Odeint}

Odeint\footnote{\href{http://odeint.com}{http://odeint.com}}
is a modern C++ library for numerically solving Ordinary Differential
Equations. It is developed in a generic way using Template Metaprogramming
which leads to extraordinary high flexibility at top performance. The numerical
algorithms are implemented independently of the underlying arithmetics. This
results in an incredible applicability of the library, especially in
non-standard environments. For example, odeint supports matrix types, arbitrary
precision arithmetics and can be easily adopted to use either CUDA or OpenCL
frameworks.

In this work odeint is used as a basis for comparison of CUDA and OpenCL
libraries.

\subsection{Thrust}

Thrust%
\footnote{\href{http://thrust.github.com}{http://thrust.github.com}}
is a parallel algorithms library which resembles the C++ Standard Template
Library. Thrust's high-level interface greatly enhances developer
productivity while enabling performance portability between GPUs and multicore
CPUs. Thrust is distributed with the NVIDIA CUDA Toolkit since version 4.1.

\subsection{VexCL}

VexCL%
\footnote{\href{https://github.com/ddemidov/vexcl}{https://github.com/ddemidov/vexcl}}
is a vector expression template library for OpenCL. It has been created for ease
of OpenCL developement with C++.  VexCL strives to reduce the amount of boilerplate
code needed to develop OpenCL applications. The library provides convenient and
intuitive notation for vector arithmetic, reduction, and sparse matrix-vector
multiplication. Multi-device and even multi-platform computations are
supported. 

\subsection{ViennaCL}

The Vienna Computing Library%
\footnote{\href{http://viennacl.sourceforge.net}{http://viennacl.sourceforge.net}}
(ViennaCL) is a scientific computing library written in C++ and based on
OpenCL. It allows simple, high-level access to the vast computing resources
available on parallel architectures such as GPUs and is primarily focused on
common linear algebra operations (BLAS levels 1, 2 and 3) and the solution of
large systems of equations by means of iterative methods with optional
preconditioner.

%Odeint supports Thrust and VexCL natively, but for ViennaCL we needed to
%provide adaptation code. Since ViennaCL already supports expression templates
%it can directly be used with the \code{vector_space_algebra} of odeint. There
%is no need to introduce an additional algebra or new operations. So in order to
%use \code{viennacl::vector} with odeint we only only needed to adapt the
%resizing operation. Resizing in odeint is necessary since many solvers need
%temporary state types. These state types need to be constructed and initialized
%which is done by the resizing mechanism of odeint.
%
%The resizing mechanism of odeint consist of three class templates. These
%classes are \code{is_resizeable<>} which is simply a meta function telling
%odeint if the type is really resizable. The second class is
%\code{same_size_impl<>} which has a static method \code{same_size} taking two
%\code{state_type} instances as arguments and returning if both instances have
%the same size. The third class is \code{resize_impl<>} which performs the
%actual resizing. These classes have a default implementation and can be
%specialized for any type.  For ViennaCL the specialization is very simple and
%is presented on \figref{fig:adapt:viennacl}.
%
%We were only able to test damped harmonic oscillator example with ViennaCL,
%since the library lacks such vector operations as elementwise multiplication or
%function application necessary for the other examples.  Nevertheless we
%consider comparison with ViennaCL interesting enough to include in this paper.
%Indeed, ViennaCL and VexCL employ somewhat different approaches to OpenCL
%kernel generation. ViennaCL has limited number of kernels, which coincide
%functionally with BLAS level 1 routines. These kernels are compiled in batch at
%the program start to allow for faster initialization. However, due to this
%design decision each vector expression may result in launch of more than one
%kernel.  On the other hand, VexCL generates and compiles single kernel for each
%vector expression it encounters.  This leads to higher initialization overhead,
%but should prove more effective in the long runs. It should be noted that main
%aim of ViennaCL is provision of iterative solvers for large sparse systems of
%equations. In this context complex vector expressions are rare and we think
%that authors of ViennaCL made correct design decision.  However, we think it is
%interesting to compare approaches of VexCL and ViennaCL.

\section{Adapting odeint}

\begin{figure}
\begin{lstlisting}
typedef std::array<double, 3> state_type;
state_type x1, x2, x3
// Initialize x1 and x2.

double dt = 0.1;
odeint::range_algebra algebra;
// The following line computes x1 = x2 + dt * x3 for all elements of x1 and x2:
algebra.for_each2(x1, x2, x2, default_operations::scale_sum1(1.0,dt));
\end{lstlisting}
\caption{An example of range algebra in odeint.}
\label{fig:odeintops}
\end{figure}

Odeint provides a mechanism which lets the user change the way how the
elementary numerical computations are performed. This mechanism consists of a
combination of a state type, the algebra and the operations. The state type represents the
phase space of the ODE. It is usually a vector type like
\code{std::vector<>} or \code{std::array<>}, but if can a more advance container like compile-time sequences from Boost.Fusion or vectors living on the GPU. The algebra is responsible for
iterating through all elements of the state whereas the operations are
performing the elementary operations. \figref{fig:odeintops} provides an
example of using odeint's range algebra. The range algebra is devoted to iterate through state types fullfilling the concepts of Boost.Range. In the example, a \code{for_each3} is used, which means that
three state types are iterated. The operation is a \code{scale_sum2} which simply
calculates \code{x1[i] = 1 * x2[i] + dt * x3[i]}. Note, that this is already the (out-of-place) formula for the Euler method.

class template steppers, with parameter, state, algebra, operations


Odeint provides a set of predefined algebras, which includes:
\begin{itemize}
    \item \code{range_algebra}: default algebra which works on Boost.Ranges
    \item \code{array_algebra}: specialized algebra for boost::array
    \item \code{fusion_algebra}: algebra for compile-time sequences like
	\code{boost::fusion::vector}, \code{std::tuple}, etc.
    \item \code{vector_space_algebra}: algebra for vector space types which
	provide overloaded arithmetic operators for elementwise operations.
\end{itemize}

Many libraries for vector and matrix types provide expression templates for the
elementary operations. Such libraries do not need an own algebra but can be
used with the \code{vector_space_algebra} and the \code{default_operations}
which simply calls the operations directly on the matrix or vector type. In
this case only odeint resizing mechanism has to be adapted.

In the following subsections we describe the odeint adaptation for GPGPU libraries
under consideration. We should mention that odeint now supports all of the
mentioned libraries natively. However, providing adaptation examples serves our
goal of comparing ease of use of the libraries.

\subsection{Thrust}
\subsection{VexCL}
\subsection{ViennaCL}

\section{Numerical experiments}

typical use cases of solving ODEs on GPU, parameter studies, large systems, discretization of PDEs...

\subsection{Lorenz Attractor Ensemble}

In the first example we will use the Lorenz system \cite{Lorenz}. The Lorenz system is a system of three coupled ODEs
which shows chaotic behavior for a large range of parameters. It is one of the most used toying ODE in the nonlinear dynamics community. The ODE of the Lorenz system reads
\begin{align}
    \frac{\de x}{\de t} &= -\sigma \left( x - y \right), \\
    \frac{\de y}{\de t} &= R x - y - xz, \\
    \frac{\de z}{\de t} &= -bz + xy.
\end{align}

Interesting question around the Lorenz system usually arise with dependence on one of its parameters. For example one might want to study the dependence on the Lyapunov exponents -- a measure for chaoticity -- on the parameter $R$. Therefore, one would create a large set of Lorenz systems (each with a different parameter $R$), pack them all into one system and solve them simultaneously. To show how this can be done we have omitted the step of solving the Lyapunov exponent, but solve only the ensemble Lorenz system for demonstration purpose and performance comparision. The full problem of computing the Lyapunov exponent would also require to solve the evolution of perturbations and some kind of renormalization. 

introduce the termini ensemble here?

\subsection{Chain of Coupled Phase Oscillators}

a phase oscillator is not reduced...

As a second example we choose a chain of coupled phase oscillators, consisting of a very large number of individual phase oscillators. A phase oscillator is reduced version of a autonomous oscillator where the state
is described by a $2\pi$ periodic variable \cite{Pikovsky-Rosenblum,Kuramoto,scholarpedia articles} which grows linear in time $\de \phi/dt = \omega$. $\omega$ is here the phase velocity. 

Therefore, interesting behavior can only
be observed if two or more oscillators are coupled. In fact, a system of
coupled phase oscillators is a prominent example of an emergent system where
the coupled system shows a more complex behavior than its constitutes.

synchronization, traveling waves, phase chaos, amplitude death


The concrete example we analyze here is:
\begin{equation}
    \frac{\de \phi_i}{\de t} = \omega_i + \sin( \phi_{i+1} - \phi_i) + \sin( \phi_i
    - \phi_{i-1}).
\end{equation}
The index $i$ denotes here the $i$-th phase in the chain.



\subsection{Damped Harmonic Oscillator Ensemble}

dependence on an external parameter (the time)
include $x^3$?

\subsection{Disordered Hamiltonian lattice}

equation, Hamiltonian system, energy conservation, phase volume conservation

symplectic steppers must be used

cite Mario, localization, thermalization

usage of dense matrix types for demonstration purposes


\section{Results}

\begin{figure}
    \begin{center}
	\includegraphics[width=\textwidth]{data/lorenz_ensemble/perfcmp}
    \end{center}
    \caption{Lorenz attractor ensemble results}
    \label{fig:lorenz:perf}
\end{figure}

\begin{figure}
    \begin{center}
	\includegraphics[width=\textwidth]{data/phase_oscillator_chain/perfcmp}
    \end{center}
    \caption{Phase oscillator chain results}
    \label{fig:phase:perf}
\end{figure}

\begin{figure}
    \begin{center}
	\includegraphics[width=\textwidth]{data/damped_oscillator/perfcmp}
    \end{center}
    \caption{Damped oscillator ensemble results}
    \label{fig:phase:perf}
\end{figure}

\begin{figure}
    \begin{center}
	\includegraphics[width=\textwidth]{data/disordered_ham_lattice/perfcmp}
    \end{center}
    \caption{Disordered Ham lattice results}
    \label{fig:phase:perf}
\end{figure}

\begin{figure}
    \begin{center}
	\subfigure[
	Damped oscillator ensemble
	]{\includegraphics[width=0.4\textwidth]{data/damped_oscillator/scaling}}\quad
	\subfigure[
	Disordered Ham lattice
	]{\includegraphics[width=0.4\textwidth]{data/disordered_ham_lattice/scaling}}\\
	\subfigure[
	Lorenz attractor ensemble
	]{\includegraphics[width=0.4\textwidth]{data/lorenz_ensemble/scaling}}\quad
	\subfigure[
	Damped phase oscillator chain
	]{\includegraphics[width=0.4\textwidth]{data/phase_oscillator_chain/scaling}}
    \end{center}
    \caption{VexCL scaling with multigpu computation}
    \label{fig:scaling}
\end{figure}

\section{Conclusion}

Performance-wise, there is almost no difference between various platforms and
libraries when those are run on the same hardware. As we have shown, various
computational problems may be solved effectively in terms of both human and
machine time with help of modern high level libraries.  There are some
differences in the programming interfaces of the libraries which may be crucial
for ones specific application. 

Thrust is more low level and its interface is very close to C++ STL library.
OpenCL libraries that we looked at provide more convenient interface for a
scientific programmer. VexCL has richer set of elementwise vector operations,
but ViennaCL has extensive set of sparse linear systems solvers (very important
feature which we did not discuss in this paper).

Regarding CUDA vs OpenCL comparison, we believe that OpenCL has two major
advantages w.r.t. CUDA: first, it has much wider range of supported hardware
which is only going to widen with time, since OpenCL is open standard supported
by major hardware producers. Second advantage of OpenCL is at the same time its
drawback: one has to (or may to) compile his kernels at compile time. This adds
overhead notable for smaller workloads but at the same time it allows one to
transparently build much more effective kernels, as it has been shown in this
paper. 

\section{Acknowledgments}

This work has been partially supported by RFBR grant No 12-07-0007. We also
would like to thank Gradient
JSC\footnote{\href{http://www.gradient-geo.com/en}{http://www.gradient-geo.com/en}}
for kindly provided hardware.

\nocite{*}
\bibliographystyle{model1-num-names}
\bibliography{ref}

\end{document}
